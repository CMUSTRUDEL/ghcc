#!/usr/bin/env python
r"""A fake gcc implementation which records input/output files, adds -O0 flag, and then calls real gcc.
"""
import sys
import argparse
import subprocess
import os


def filter_filenames(args):
    return [arg for arg in args if arg.endswith('.c') or arg.endswith('.h')]


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-o')
    parser.add_argument('-c', action='store_true')
    parser.add_argument('-O', nargs='?')
    parser.add_argument('-Wall', action='store_true')
    parser.add_argument('-mabi')  # ignored
    parser.add_argument('-march')  # ignored
    parser.add_argument('-mtune')  # ignored
    parser.add_argument('-mlittle-endian', action='store_true')  # ignored
    parser.add_argument('-mapcs', action='store_true')  # ignored
    parser.add_argument('-mno-sched-prolog', action='store_true')  # ignored
    args, unknown_args = parser.parse_known_args(sys.argv[1:])

    filenames = filter_filenames(unknown_args)
    out_file = None
    if args.o:
        out_file = args.o
    elif args.c:
        for f in filenames:
            if f.endswith('.c'):
                out_file = os.path.splitext(f)[0] + ".o"
    if out_file is None:
        out_file = 'a.out'

    known = []
    if args.c:
        known.append("-c")

    out_path = os.path.abspath(out_file)
    # TODO: Read this path from ENV
    out = open("/data2/apjaffe/gcc_logs2/" + out_path.replace("/", "_"), "w")
    out.write(os.getcwd() + "\n" + out_file + "\n" + str(filenames) + "\n" + " ".join(sys.argv[1:]) + "\n")

    # When multiple -O options are specified, the last one takes precedence
    try:
        # igcc = "arm-linux-gnueabi-gcc"
        gcc = "gcc"  # "gcc-4.7"
        newarg = ["/usr/bin/" + gcc] + known + unknown_args + ["-o", out_file, "-O0", "-g"]
        proc = subprocess.Popen(newarg, stderr=subprocess.PIPE)
        proc.wait()
        stderror = proc.stderr.read()
        sys.stderr.write(stderror)
        if proc.returncode != 0:
            print("Args: " + str(newarg))
            print("RETURN CODE: %d" % proc.returncode)
        out.write("%d\n" % proc.returncode)
        with open("/tmp/log", "a") as log:
            log.write(" ".join(sys.argv) + "\n")
            log.write(stderror)
            log.write("Return code: %d\n" % proc.returncode)
        if proc.returncode != 0:
            exit(proc.returncode)
    except Exception as e:
        print(e)
        print("ERROR OCCURED")
        out.write(str(e))
        with open("/tmp/log", "a") as log:
            log.write(str(e))
        exit(2)


if __name__ == "__main__":
    main()
